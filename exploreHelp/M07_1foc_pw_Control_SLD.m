% ====================================================================== %
% Script for clinical data.
% Created on July, 2025
% Based on SWIFT version for ACS now for DoF RPL framework
% Description:
% BF Data (Acq in 2025 in Avendano CONTROL July 2025), reference Wisconsin*
% (when load select % MONOFOC oR PW)
%
% Specific folder data: "bf_SavedDataCurvilinearPW"
% Reading BF data -> Spectral Data-> RSLD & SWIFT
% Saves ROIs (previously generated by inspection)
% Saves MAPS DoFs
% ====================================================================== %

%%
init
warning('off')
%% WISCONSIN SPECS

% n_wisconsin = 3.76;
% b_wisonsin  = -54.81; % [dB]
alpha_ref   = 0.52; % [dB/cm/MHz]
sos_ref     = 1539; % [m/s]

n_wisconsin = 3.8;
n_healthy_lu = 1.4;
delta_n_lu  = n_healthy_lu - n_wisconsin; % delta_n_healthy = -2.4

b_wisonsin      = -55; % [dB]
b_healthy_lu    = -40; % [dB]
delta_b_lu  = b_healthy_lu - b_wisonsin; % delta_b_healthy = 27dB

% SUMARY (Lu et al)
% Healhty   : delta_n = -2.4, delta_b = 15dB
% Fat       : delta_n = -2.5, delta_b = 27dB
%%

caseData = 'AS';
% caseData = 'rest';

mean2d  = @(x) mean(x(:));
std2d   = @(x) std(x(:));
cv2d    = @(x) 100*std(x(:))/mean(x(:));
calc2dStats     = {@(x) mean(x(:)), @(x) std(x(:)), @(x) 100*std(x(:))/mean(x(:))};


% General directory
baseDir     = 'D:\emirandaz\qus\data\liver\bf_SavedDataCurvilinearPW\';

% Sample and Reference directories
sampleDir   = fullfile(baseDir,caseData,'sam');
refsDir     = fullfile(baseDir,caseData,'ref');

% Outcomes directory

resultsOut  = 'RSLD_control_out';
figuresOut  = 'RSLD_control_fig';

polFolder   = 'polarFig';

resultsDir  = fullfile(baseDir,resultsOut);
figsDir     = fullfile(baseDir,figuresOut);
figsPolDir  = fullfile(baseDir,figuresOut, polFolder);

if ~exist(resultsDir) mkdir(resultsDir); end
if ~exist(figsDir) mkdir(figsDir); end
if ~exist(figsPolDir) mkdir(figsPolDir); end

% ROI MANUAL 
roi_already     = true;
roisDir         = fullfile(baseDir,'roisControl');
if ~exist(roisDir) mkdir(roisDir); end

range_bmode     = [-60 0];
range_depth     = [0 13];
range_acs       = [0 1.2];
transparency    = 0.65;
Np2dB           = 20*log10(exp(1));
dB2Np           = 1/Np2dB;
fontSize        = 14;

plotBmode       = false;
plotSpectrum    = false;
plotPolar       = false;
plotRect        = true;

% Read sample files
sampleFiles = dir(fullfile(sampleDir,'*.mat'));

% Specific sample
% acqDir = dir(fullfile(sampleDir,'016-03.mat')); %65*ma
% acqDir = dir(fullfile(sampleDir,'007-05.mat')); %*ma
% acqDir = dir(fullfile(sampleDir,'014-01.mat')); %*ma
% acqDir = dir(fullfile(sampleDir,'016-06.mat')); %emz
% sampleFiles     = dir(fullfile(sampleDir,'020-05.mat')); %dv

%% SPECTRAL METHOD PARAMETERS

pars.P           = 512; % NFFT for 10wl is 256, 20wl 512
% pars.bw          = [1.5 3.5]; % [MHz]
pars.bw          = [1.35 3.65]; % [MHz]
pars.overlap     = 0.8;
pars.blocksize   = 10; % wavelengths
pars.blocklines  = 8;
pars.window_type = 3; %  (1) Hanning, (2) Tuckey, (3) Hamming, (4) Tchebychev
pars.saran_layer = false;
pars.ratio_zx    = 1;

pars.lambda     = 2*1540/(1.5E6 + 4E6);
pars.NFFT       = 256;

%% GENERAL REGULARIZATION SETTINGS


%%

for iFile = 1:length(sampleFiles)

%% Loading file and variables
% samName = "000345400_IHR_F1";
samName = sampleFiles(iFile).name(1:end-4);
SAM     = load(fullfile(sampleDir,samName+".mat")).MONOFOC; % Focus
% fprintf("Loading sample: %s \n", samName)
fprintf("Loading sample %d / %d: %s \n", iFile, length(sampleFiles), samName)

bmode_sam   = SAM.bMode;
SAM.x       = SAM.xr; % original in in mm °, so °
SAM.z       = SAM.zr;
r0          = SAM.r0;

caption = strrep(samName, '_', '-');

%% Selecting ROI
bmodeFull = SAM.bMode;

if ~roi_already

    figure('Units','centimeters', 'Position',[5 5 15 15]),
    imagesc(SAM.x, SAM.z*1E2,bmode_sam,range_bmode);
    colormap gray; clim(range_bmode);
    hb2=colorbar; ylabel(hb2,'dB')
    xlabel('\bfAngle [°]'); ylabel('\bfDepth [cm]');
    title(caption)

    confirmation = '';
    while ~strcmp(confirmation,'Yes')
        rect = getrect;
        confirmation = questdlg('Sure?');
        if strcmp(confirmation,'Cancel')
            disp(rect)
            break
        end
    end
    close,

else
% rois already saved execute full code
load(fullfile(roisDir,samName+".mat"),'rect');
    
pars.x_roi     = [rect(1), rect(1)+rect(3)];      % [º]
pars.z_roi     = [rect(2), rect(2)+rect(4)]*1E-2; % [m]

%% PACKAGE DATA FOR SPECTRAL FUNCTIONS

refFiles    = dir([refsDir,'\*.mat']);
% refFiles = refFiles(x,:); % for select specific "x" refFiles
numRefs     = length(refFiles); 
REF         = load( fullfile(refsDir, refFiles(1).name) ).MONOFOC;
newrf       = nan([size(REF.rf), numRefs], 'like', REF.rf); % Use 'like' for type consistency
for i = 1:numRefs
    newrf(:,:,i) = load( fullfile(refsDir,refFiles(i).name) ).MONOFOC.rf(:,:,1); % Directly extract rf, avoiding redundant variables
end

REF.rf  = newrf;
REF.acs = alpha_ref;
REF.c0  = sos_ref;

% Just in case
REF.x   = SAM.x;
REF.z   = SAM.z;
bmode_ref = my_RF2Bmode(REF.rf(:,:,1));

%% BMODE CHECK

if (plotBmode)
deadBand = 0.1e-2;
figure,
set(gcf, 'Units', 'pixels', 'Position', [50, 100, 1200, 600]); % [x, y, width, height]

subplot(121), 
imagesc(SAM.x, SAM.z*1E2, bmode_sam, range_bmode), 
% axis("image"), 
hold on;
rectangle('Position', [1, 1E2, 1, 1E2].*[pars.x_roi(1) pars.z_roi(1) pars.x_roi(2)-pars.x_roi(1) pars.z_roi(2)-pars.z_roi(1)], ...
        'EdgeColor','w', 'LineWidth', 2, 'LineStyle','--'), hold off;
clim(range_bmode)
cb = colorbar;
cb.Label.String = 'dB'; % Add the label "dB"
xlabel('Lateral [°]'), ylabel('Depth [cm]');
title(caption)
ylim([deadBand*1000 range_depth(2)])
colormap('gray')

subplot(122), 
imagesc(REF.x, REF.z*1E2, bmode_ref, range_bmode), 
% axis("image");
rectangle('Position',  [1, 1E2, 1, 1E2].*[pars.x_roi(1) pars.z_roi(1) pars.x_roi(2)-pars.x_roi(1) pars.z_roi(2)-pars.z_roi(1)], ...
        'EdgeColor','w', 'LineWidth', 2, 'LineStyle','--'), hold off;
clim(range_bmode)
cb = colorbar;
cb.Label.String = 'dB'; % Add the label "dB"
xlabel('Lateral [°]'), ylabel('Depth [cm]');
title('REF')
colormap('gray')
ylim([deadBand*1000 range_depth(2)])
end

%% %% POWER SPECTRA ESTIMATION

%%%%%%%%%%%%% SAM %%%%%%%%%%%%%
% spectralData_sam = calc_powerSpectra_prox_dis(SAM, pars);
spectralData_sam = calc_powerSpectraFull_prox_dis(SAM, pars);


%%%%%%%%%%%%% REF %%%%%%%%%%%%%
% spectralData_ref = calc_powerSpectra_prox_dis(REF, pars);
spectralData_ref = calc_powerSpectraFull_prox_dis(REF, pars);


%% PLOT SPECTRUM BY DEPTH

ratio_dB    = -20;
ratio       = db2mag(ratio_dB);

Sfull       = spectralData_sam.Sfull; % POWER LAW 3DOF

[m,n,~]     = size(spectralData_sam.Sfull);

nLines      = 3;
lin_cen     = round(n / 2); 
lat_range   = max(1, lin_cen-fix(nLines/2)):min(n, lin_cen+fix(nLines/2)); 

S_2d        = squeeze(mean(spectralData_sam.Sfull(:, lat_range, :), 2)); % Mean over 2nd dim (lateral)
S_2d_dB     = pow2db(S_2d ./ max(S_2d, [], 2));

if plotSpectrum

figure;
set(gcf,'units','normalized','outerposition',[0 0.1 0.5 0.5]); box on;

subplot(1,2,1)
imagesc(spectralData_sam.bandFull, spectralData_sam.depth*1e3, S_2d_dB),
xline(pars.bw(1), 'w--', 'LineWidth', 2)
xline(pars.bw(2), 'w--', 'LineWidth', 2)
xlim([0 SAM.fs/2]*1e-6); % visualize only positive size
xlabel('Frequency [MHz]');
ylabel('Depth [mm]');
h2 = colorbar; 
ylabel(h2,'dB');
title('SAM Norm Power Spectrum by depth');

subplot(1,2,2)
plot(spectralData_sam.bandFull, S_2d_dB(1, :), 'DisplayName', 'Top')
hold on, grid on;
plot(spectralData_sam.bandFull, S_2d_dB(round(m/2), :), 'DisplayName', 'Half')
plot(spectralData_sam.bandFull, S_2d_dB(end, :), 'DisplayName', 'Bottom')
yline(ratio_dB, 'k--', 'DisplayName', '')
xline(pars.bw(1), 'k--', 'DisplayName', '')
xline(pars.bw(2), 'k--', 'DisplayName', '')
xlim([0 SAM.fs/2]*1e-6); % visualize only positive size
hold off;
xlabel('Frequency [MHz]');
ylabel('Norm Power Spectrum [dB]');
title('SAM Norm Power Spectrum');
legend('Location', 'Best');

exportgraphics(gcf,fullfile(figsDir,samName+"_powSp.png"), ...
   'Resolution','300')
end


%% UFR strategy

%SLD STEP BY STEP

% SAMPLE Sp an Sd
Sp_sam     = spectralData_sam.Sp;
Sd_sam     = spectralData_sam.Sd;
bandFull   = spectralData_sam.bandFull;  % [MHz]
zd_zp      = spectralData_sam.zd_zp;     % [m]

% REFERENCE Sp an Sd
Sp_ref = spectralData_ref.Sp;
Sd_ref = spectralData_ref.Sd;

% COMPENSATION ATTENUATION
acs_ref     = alpha_ref; % [dB/cm/MHz]
att_ref     = acs_ref*bandFull /Np2dB; % vector [Np/cm]
att_ref_map = ones(size(Sp_sam)) .* reshape(att_ref, 1, 1, []); % 3D array as SLogRatio
% att_ref_map = reshape(att_ref, 1, 1, [])
SLogRatioFull = log(Sp_sam./Sd_sam) - ( log(Sp_ref./Sd_ref) - 4*zd_zp*1E2*att_ref_map ); % (rows, cols, freqChannels)

% USABLE FREQUENCY RANGE
range       = bandFull > pars.bw(1) & bandFull < pars.bw(2);
SLogRatio   = SLogRatioFull(:,:,range);
band        = bandFull(range);


%% REGULARIZED METHODS 

%%%%%%%%%%%%%%%%%% RSLD %%%%%%%%%%%%%%%%%%
mu1 = 10^3.5;
mu2 = 10^3.5;
[m, n, p] = size(SLogRatio);
mask = ones(m,n,p);
A1 = kron( 4*zd_zp*1E2*band , speye(m*n) );
A2 = kron( ones(size(band)) , speye(m*n) );
tol = 1e-3;
[Bn,~] = AlterOpti_ADMM(A1, A2, SLogRatio(:),mu1,mu2,m,n,tol,mask(:));
acs_rsld = reshape(Bn*Np2dB,m,n);
%%%%%%%%%%%%%%%%%% RSLD %%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%% SWIFT %%%%%%%%%%%%%%%%%%

muBswift = 10^3; muCswift = 10^0.5;
ratioCutOff = 10;
reject = 0.1;
extension = 3;

% First iteration
[~,Cn] = optimAdmmTvTikhonov(A1,A2,SLogRatio(:),muBswift,muCswift,m,n,tol,mask(:));
bscMap = reshape(Cn*Np2dB,m,n);

% Weight map
w = (1-reject)*(abs(bscMap)<ratioCutOff)+reject;
wExt = movmin(w,extension);

% Weight matrices and new system
W = repmat(wExt,[1 1 p]);
W = spdiags(W(:),0,m*n*p,m*n*p);
bw = W*SLogRatio(:);        
A1w = W*A1;
A2w = W*A2;

% Second iteration
[Bn2,cN] = optimAdmmWeightedTvTikhonov(A1w,A2w,bw,muBswift,muCswift,m,n,tol,mask(:),w);
acs_swift = reshape(Bn*Np2dB,m,n);
CSWIFT = reshape(Cn*Np2dB,m,n);    

%% METRICS

[m_a, s_a, cv_a]    = deal(calc2dStats{1}(acs_rsld), calc2dStats{2}(acs_rsld), calc2dStats{3}(acs_rsld));
[m_a2, s_a2, cv_a2] = deal(calc2dStats{1}(acs_swift), calc2dStats{2}(acs_swift), calc2dStats{3}(acs_swift));


fprintf('-----RSLD---\n');
fprintf('α_s        : %.4f ± %.4f, %%CV = %.4f\n', round(m_a, 3), round(s_a, 4), round(cv_a, 4));


fprintf('-----SWIFT---\n');
fprintf('α_s        : %.4f ± %.4f, %%CV = %.4f\n', round(m_a2, 3), round(s_a2, 4), round(cv_a2, 4));

maps_results_acs{1}.alpha = acs_rsld;
maps_results_acs{1}.method = 'rsld';

maps_results_acs{2}.alpha = acs_swift;
maps_results_acs{2}.method = 'swift';


methods      = {'RSLD', 'SWIFT'};
method_labels = { ...
    '\mathrm{RSLD}', ...
    '\mathrm{SWIFT}', ...
};
%% DISPLAY OVERLAY SIMPLE RECT
if plotRect

units           = 1E2;
bmodeFull       = bmode_sam;
% colorImg        = bigImg(acs_sam, spectralData_sam.rf_roi);
range_bmode     = [-60 0];
x_img           = spectralData_sam.lateral;
z_img           = spectralData_sam.depth*units;
xFull           = SAM.x;
zFull           = SAM.z*units;

[X,Z]   = meshgrid(xFull,zFull);
roi     = X >= x_img(1) & X <= x_img(end) & Z >= z_img(1) & Z <= z_img(end);

% %%%%%%%%%%%%%%%%%%%%%%% alpha %%%%%%%%%%%%%%%%%%%%%%%%
indices_alpha = [1, 2];  % Corresponden a RFM and TNV-RFM

figure('Units','pixels', 'Position',[50, 100, 1500, 500]) % [x, y, width, height]
tiledlayout(1,3, 'TileSpacing','compact', 'Padding','compact')

% Bmode
t1 = nexttile();
imagesc(xFull,zFull,bmodeFull,range_bmode); % axis image;
title(caption)
ylim(range_depth)
hold on
contour(xFull,zFull,roi,1,'w--')
hold off
xlabel('Lateral [°]')
ylabel('Depth [cm]')
hBm = colorbar('Ticks',-60:20:0);
% hBm = colorbar;
hBm.Label.String = 'dB';
hBm.Location = 'westoutside';
set(gca, 'fontsize', fontSize);

% RFM

% alpha maps
for i = 1:length(indices_alpha)
    idx = indices_alpha(i);
    nexttile;
    [~,~,hColor] = imOverlayInterp(bmodeFull, maps_results_acs{idx}.alpha, range_bmode, range_acs, ...
                                   transparency, x_img, z_img, roi, xFull, zFull);
    axis normal;
    hold on;
    contour(xFull, zFull, roi, 2, 'w--')
    hold off;
    ylim(range_depth)
    xlabel('Lateral [°]'), 
    % ylabel('Depth [cm]');
   
    hColor.Label.String = 'dB\cdotcm^{-1}\cdotMHz^{-1}';
    title(sprintf('$%s: \\alpha_s = %.2f \\pm %.2f, \\%%CV = %.2f$', ...
        method_labels{idx}, ...
        mean(maps_results_acs{idx}.alpha(:), 'omitnan'), ...
        std(maps_results_acs{idx}.alpha(:), 'omitnan'), ...
        abs(cv2d(maps_results_acs{idx}.alpha))), ...
        'Interpreter', 'latex');
    set(gca, 'fontsize', fontSize);
end
colormap(t1,'gray')
exportgraphics(gcf,fullfile(figsDir,"acs_rect_"+samName+".png"), ...
   'Resolution','300')

end

%%  DISPLAY OVERLAY SIMPLE POLAR
if plotPolar

xPolar  = SAM.xp;
zPolar  = SAM.zp + 0.0101; % Trans.radiusMm*1e-3*(1-cos(phi(1)))
% zPolar  = SAM.zp;
z0Polar = SAM.z0p; 
r0      = SAM.r0;

parProbe = getparam('C5-2v');
[~,~,z0Polar2] = impolgrid(size(bmode_sam), SAM.z(end)+r0, parProbe);

% Plot in cartesian cords
[TH_acs,R_acs]          = meshgrid(-x_img*pi/180 + pi/2,z_img/100+r0);
[xPolarACS,zPolarACS]   = pol2cart(TH_acs,R_acs);
zPolarACS               = zPolarACS + z0Polar;

%%%%%%%%%%%%%%%%%%%%%%% BMODE %%%%%%%%%%%%%%%%%%%%%%%
figure('Units', 'pixels', 'Position', [50, 100, 400, 300]); % [x, y, width, height]
[ax1,~] = imOverlayPolar(bmodeFull,ones(size(maps_results_acs{1}.alpha)),range_bmode,range_acs,0, ...
    xPolar,zPolar,xPolarACS,zPolarACS);
% yticks(ax1,[4 8 12 16])
xlabel(ax1,'Lateral [cm]'), ylabel(ax1,'Axial [cm]')
title(ax1, samName, 'Interpreter', 'none');
xlim([-9 9])
ylim(range_depth)
hold on
contour(xPolar*1e2, zPolar*1e2, roi,1,'w--')
hold off
set(gca, 'fontsize', fontSize);
% exportgraphics(gcf,fullfile(figsPolDir,"sam_"+samName+"_pol"+num2str(idx)+".png"), ...
% 'Resolution','300')

%% QUS PARAMETERS

%%%%%%%%%%%%%%%%%%%%%%%% alpha %%%%%%%%%%%%%%%%%%%%%%%%

for i = 1:length(indices_alpha)
    figure('Units', 'pixels', 'Position', [50, 100, 400, 300]); % [x, y, width, height]
    idx = indices_alpha(i);

    % [ax1,~] = imOverlayPolar(bmodeFull,ones(size(maps_results_dof{1}.alpha)),range_bmode,range_acs,0, ...
    %     xPolar,zPolar,xPolarACS,zPolarACS);
    [ax1,~] = imOverlayPolar(bmodeFull,maps_results_acs{idx}.alpha,range_bmode,range_acs,transparency, ...
        xPolar,zPolar,xPolarACS,zPolarACS);
    % yticks(ax1,[4 8 12 16])
    xlabel(ax1,'Lateral [cm]'), ylabel(ax1,'Axial [cm]')

    title(ax1, sprintf('$%s: \\alpha_s = %.2f \\pm %.2f, \\%%CV = %.2f$', ...
        method_labels{idx}, ...
        mean(maps_results_acs{idx}.alpha(:), 'omitnan'), ...
        std(maps_results_acs{idx}.alpha(:), 'omitnan'), ...
        abs(cv2d(maps_results_acs{idx}.alpha))), ...
        'Interpreter', 'latex');

    xlim([-9 9])
    ylim(range_depth)
    hold on
    contour(xPolar*1e2, zPolar*1e2, roi,1,'w--')
    hold off
    % colorbar 
    % hColor.Label.String = 'dB\cdotcm^{-1}\cdotMHz^{-1}';
    set(gca, 'fontsize', fontSize);
    exportgraphics(gcf,fullfile(figsPolDir,"acs_pol_"+samName+num2str(idx)+".png"), ...
    'Resolution','300')
end

end

%% PLOT ACS LINES by DEPTH

% z_ACS   = spectralData_sam.depth*1e2; % [cm]
% m       = length(z_ACS);
% 
% 
% fit  = [z_ACS',ones(m,1)]\mean(acs_rsld,2);
% fit2 = [z_ACS',ones(m,1)]\mean(acs_swift,2); 
% 
% figure('Units','centimeters', 'Position',[5 5 20 10]);
% tiledlayout(1,2, "TileSpacing","compact", "Padding","compact")
% 
% nexttile,
% plot(z_ACS,mean(acs_rsld,2))
% grid on
% xlabel('Depth [cm]')
% ylabel('ACS [dB/cm/MHz]')
% % yline(liverAcs,'k--')
% title(sprintf("RSLD: ACS = %.2fz + %.2f",fit(1),fit(2)))
% ylim([0 2])
% hold on,
% plot(z_ACS,fit(1)*z_ACS + fit(2), 'r--')
% set(gca, 'fontsize', fontSize);
% 
% nexttile,
% plot(z_ACS,mean(acs_rsld,2))
% grid on
% xlabel('Depth [cm]')
% ylabel('ACS [dB/cm/MHz]')
% % yline(liverAcs,'k--')
% title(sprintf("SWIFT: ACS = %.2fz + %.2f",fit2(1),fit2(2)))
% ylim([0 2])
% hold on,
% plot(z_ACS,fit2(1)*z_ACS + fit2(2), 'r--')
% set(gca, 'fontsize', fontSize);

end
%% SAVING DATA
if roi_already
    % Saving ACS maps and ROI
    save(fullfile(resultsDir,samName+".mat"), ...
        'maps_results_acs','rect')
else
    % first time working with roi
    save(fullfile(roisDir,samName+".mat"), ...
    'rect')

end

close all
pause (0.5);
end
%% Auxiliary functions
% Get delays
function [t_delay] = getRXDelays(Trans, t, n_elements, n_pulses, sound_speed, wvl)

t_delay = zeros(length(t), n_elements, n_pulses);
% (x, z) [m] Obtain positions of center of every element
element_pos_x = Trans.ElementPos(:, 1)*wvl;
element_pos_z = Trans.ElementPos(:, 3)*wvl;
phi = Trans.ElementPos(:, 4);

for n = 1:n_pulses
    for e = 1:n_elements
        focus = sound_speed*t(:)/2;
        xfocus = element_pos_x(n) + sin(phi(n)) * focus;
        zfocus = element_pos_z(n) + cos(phi(n)) * focus;
        t_delay(:,e,n) = (focus + sqrt((zfocus- element_pos_z(e)).^2 + ...
            (xfocus - element_pos_x(e)).^2))/sound_speed;
    end
end

end