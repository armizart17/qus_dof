% ====================================================================== %
% Script for clinical data.
% Created on July, 2025
% Based on SWIFT version for ACS now for DoF RPL framework
% Description:
% BF Data (Acq in 2025 in Avendano CONTROL July 2025), reference Wisconsin
% DOUBLE KIND OF ACQUISITION MONOFOCAL AND PLANEWAVE 
% (when load select % MONOFOC oR PW)
% Specific folder data: "bf_SavedDataCurvilinearPW"
% Reading BF data -> Spectral Power Law -> RPL-TV
% Saves ROIs (previously generated by inspection)
% Saves MAPS DoFs
% ====================================================================== %

%%
init
warning('off')
%% WISCONSIN SPECS

% n_wisconsin = 3.76;
% b_wisonsin  = -54.81; % [dB]
alpha_ref   = 0.52; % [dB/cm/MHz]
sos_ref     = 1539; % [m/s]

n_wisconsin = 3.8;
n_fat_lu    = 1.3;
delta_n_lu  = n_fat_lu - n_wisconsin;

b_wisonsin  = -55; % [dB]
b_fat_lu    = -28; % [dB]
delta_b_lu  = b_fat_lu - b_wisonsin;
%%

caseData = 'AS';
%caseData = 'rest';

mean2d  = @(x) mean(x(:));
std2d   = @(x) std(x(:));
cv2d    = @(x) 100*std(x(:))/mean(x(:));
calc2dStats     = {@(x) mean(x(:)), @(x) std(x(:)), @(x) 100*std(x(:))/mean(x(:))};


% General directory
baseDir     = 'D:\emirandaz\qus\data\liver\bf_SavedDataCurvilinearPW\';

% Sample and Reference directories
sampleDir   = fullfile(baseDir,caseData,'sam');
refsDir     = fullfile(baseDir,caseData,'ref');

% Outcomes directory
reguRPL     = true; % RPL
% reguRPL     = true; % LS

% AS
if reguRPL
    resultsOut  = 'resultsControl_RPL_lu';
    figuresOut  = 'figuresControl_RPL_lu';
else
    resultsOut  = 'resultsControl_LS_lu';
    figuresOut  = 'figuresControl_LS_lu';
end

polFolder = 'polarFig';

resultsDir  = fullfile(baseDir,resultsOut);
figsDir     = fullfile(baseDir,figuresOut);
figsPolDir  = fullfile(baseDir,figuresOut, polFolder);

if ~exist(resultsDir) mkdir(resultsDir); end
if ~exist(figsDir) mkdir(figsDir); end
if ~exist(figsPolDir) mkdir(figsPolDir); end

% ROI MANUAL 
roi_already     = true;
roisDir         = fullfile(baseDir,'roisControl');
if ~exist(roisDir) mkdir(roisDir); end

range_bmode     = [-60 0];
range_depth     = [0 13];
range_acs       = [0 1.2];
range_delta_b   = [15 35];
range_delta_n   = [-5 0];
transparency    = 0.65;
Np2dB           = 20*log10(exp(1));
dB2Np           = 1/Np2dB;
fontSize        = 14;

plotBmode       = false;
plotBSCdB       = true;  % plot \Delta b in dB
plotSpectrum    = false;
plotPolar       = false;
plotRect        = true;


% Read sample files
sampleFiles = dir(fullfile(sampleDir,'*.mat'));

% Specific sample
% acqDir = dir(fullfile(sampleDir,'016-03.mat')); %65*ma
% acqDir = dir(fullfile(sampleDir,'007-05.mat')); %*ma
% acqDir = dir(fullfile(sampleDir,'014-01.mat')); %*ma
% acqDir = dir(fullfile(sampleDir,'016-06.mat')); %emz
% sampleFiles     = dir(fullfile(sampleDir,'020-05.mat')); %dv

%% SPECTRAL METHOD PARAMETERS

pars.P           = 512; % NFFT for 10wl is 256, 20wl 512
pars.bw          = [1.5 3.5]; % [MHz]
pars.overlap     = 0.8;
pars.blocksize   = 10; % wavelengths
pars.blocklines  = 8;
pars.window_type = 3; %  (1) Hanning, (2) Tuckey, (3) Hamming, (4) Tchebychev
pars.saran_layer = false;

%% GENERAL REGULARIZATION SETTINGS
% Implementation parameters
par_rpl.tol        = 1e-16;
par_rpl.kmax       = 100;
par_rpl.eps_f      = 1e-16;
par_rpl.m_est      = 0; %Robust
par_rpl.ini_tol    = 1e-5;
par_rpl.df_op      = 0;
par_rpl.ini_method = 1; % METHOD LEAST SQUARES INITIALIZATION 

if reguRPL 
mu_rpl_tv          = [1E3; 1E3; 10^4.2]; % RPL
else
mu_rpl_tv          = [0.001; 0.001; 0.001]; % LS
end

for iFile = 1:length(sampleFiles)

%% Loading file and variables
% samName = "000345400_IHR_F1";
samName = sampleFiles(iFile).name(1:end-4);
SAM     = load(fullfile(sampleDir,samName+".mat")).MONOFOC; % MONOFOC
% fprintf("Loading sample: %s \n", samName)
fprintf("Loading sample %d / %d: %s \n", iFile, length(sampleFiles), samName)

bmode_sam   = SAM.bMode;
SAM.x       = SAM.xr; % original in in mm °, so °
SAM.z       = SAM.zr;
r0          = SAM.r0;

caption = strrep(samName, '_', '-');

%% Selecting ROI
bmodeFull = SAM.bMode;

if ~roi_already

    figure('Units','centimeters', 'Position',[5 5 15 15]),
    imagesc(SAM.x, SAM.z*1E2,bmode_sam,range_bmode);
    colormap gray; clim(range_bmode);
    hb2=colorbar; ylabel(hb2,'dB')
    xlabel('\bfAngle [°]'); ylabel('\bfDepth [cm]');
    title(caption)

    confirmation = '';
    while ~strcmp(confirmation,'Yes')
        rect = getrect;
        confirmation = questdlg('Sure?');
        if strcmp(confirmation,'Cancel')
            disp(rect)
            break
        end
    end
    close,

else
% rois already saved execute full code
load(fullfile(roisDir,samName+".mat"),'rect');
    
pars.x_roi     = [rect(1), rect(1)+rect(3)];      % [º]
pars.z_roi     = [rect(2), rect(2)+rect(4)]*1E-2; % [m]

%% PACKAGE DATA FOR SPECTRAL FUNCTIONS

% SAMPLE
j_sam       = 1.0;

% REFERENCE WISCONSIN
j_ref       = 1.0;

refFiles    = dir([refsDir,'\*.mat']);
% refFiles = refFiles(x,:); % for select specific "x" refFiles
numRefs     = length(refFiles); 
REF         = load( fullfile(refsDir, refFiles(1).name) ).MONOFOC;
newrf       = nan([size(REF.rf), numRefs], 'like', REF.rf); % Use 'like' for type consistency
for i = 1:numRefs
    newrf(:,:,i) = load( fullfile(refsDir,refFiles(i).name) ).MONOFOC.rf(:,:,1); % Directly extract rf, avoiding redundant variables
end

REF.rf  = newrf;
REF.acs = alpha_ref;
REF.c0  = sos_ref;

% Just in case
REF.x   = SAM.x;
REF.z   = SAM.z;
bmode_ref = my_RF2Bmode(REF.rf(:,:,1));
%% BMODE CHECK


if (plotBmode)
deadBand = 0.1e-2;
figure,
set(gcf, 'Units', 'pixels', 'Position', [50, 100, 1200, 600]); % [x, y, width, height]

subplot(121), 
imagesc(SAM.x, SAM.z*1E2, bmode_sam, range_bmode), 
% axis("image"), 
hold on;
rectangle('Position', [1, 1E2, 1, 1E2].*[pars.x_roi(1) pars.z_roi(1) pars.x_roi(2)-pars.x_roi(1) pars.z_roi(2)-pars.z_roi(1)], ...
        'EdgeColor','w', 'LineWidth', 2, 'LineStyle','--'), hold off;
clim(range_bmode)
cb = colorbar;
cb.Label.String = 'dB'; % Add the label "dB"
xlabel('Lateral [°]'), ylabel('Depth [cm]');
title(caption)
ylim([deadBand*1000 range_depth(2)])
colormap('gray')

subplot(122), 
imagesc(REF.x, REF.z*1E2, bmode_ref, range_bmode), 
% axis("image");
rectangle('Position',  [1, 1E2, 1, 1E2].*[pars.x_roi(1) pars.z_roi(1) pars.x_roi(2)-pars.x_roi(1) pars.z_roi(2)-pars.z_roi(1)], ...
        'EdgeColor','w', 'LineWidth', 2, 'LineStyle','--'), hold off;
clim(range_bmode)
cb = colorbar;
cb.Label.String = 'dB'; % Add the label "dB"
xlabel('Lateral [°]'), ylabel('Depth [cm]');
title('REF')
colormap('gray')
ylim([deadBand*1000 range_depth(2)])
end

%% POWER SPECTRA ESTIMATION
% spectralData_sam = calc_powerSpectra(SAM, pars);
spectralData_sam = calc_powerSpectra_vSimple(SAM, pars); % @
S_sam = spectralData_sam.powerSpectra;

% spectralData_ref = calc_powerSpectra(REF, pars);
spectralData_ref = calc_powerSpectra_vSimple(REF, pars); % @
S_ref = spectralData_ref.powerSpectra;

% Validate this first 
if ~isequal(size(S_sam), size(S_ref))
    % Display Fs values in MHz
    Fs_sam_MHz = SAM.fs / 1e6;
    Fs_ref_MHz = REF.fs / 1e6;
    fprintf('SAM.fs = %.2f MHz, REF.fs = %.2f MHz\n', Fs_sam_MHz, Fs_ref_MHz);

    fprintf('Incompatible sizes: S_sam [%s], S_ref [%s] — skipping.\n', ...
             mat2str(size(S_sam)), mat2str(size(S_ref)));
    continue;  % Skip to next iteration
end

SR_emz = S_sam ./ S_ref;
SR = permute(SR_emz,[3,1,2]); clear SR_emz

%% PLOT SPECTRUM BY DEPTH

ratio_dB    = -20;
ratio       = db2mag(ratio_dB);

Sfull       = spectralData_sam.Sfull; % POWER LAW 3DOF

[m,n,~]     = size(spectralData_sam.Sfull);

nLines      = 5;
lin_cen     = round(n / 2); 
lat_range   = max(1, lin_cen-fix(nLines/2)):min(n, lin_cen+fix(nLines/2)); 

S_2d        = squeeze(mean(spectralData_sam.Sfull(:, lat_range, :), 2)); % Mean over 2nd dim (lateral)
S_2d_dB     = pow2db(S_2d ./ max(S_2d, [], 2));

if plotSpectrum

figure;
set(gcf,'units','normalized','outerposition',[0 0.1 0.5 0.5]); box on;

subplot(1,2,1)
imagesc(spectralData_sam.bandFull, spectralData_sam.depth*1e3, S_2d_dB),
xline(pars.bw(1), 'w--', 'LineWidth', 2)
xline(pars.bw(2), 'w--', 'LineWidth', 2)
xlim([0 SAM.fs/2]*1e-6); % visualize only positive size
xlabel('Frequency [MHz]');
ylabel('Depth [mm]');
h2 = colorbar; 
ylabel(h2,'dB');
title('SAM Norm Power Spectrum by depth');

subplot(1,2,2)
plot(spectralData_sam.bandFull, S_2d_dB(1, :), 'DisplayName', 'Top')
hold on, grid on;
plot(spectralData_sam.bandFull, S_2d_dB(round(m/2), :), 'DisplayName', 'Half')
plot(spectralData_sam.bandFull, S_2d_dB(end, :), 'DisplayName', 'Bottom')
yline(ratio_dB, 'k--', 'DisplayName', '')
xline(pars.bw(1), 'k--', 'DisplayName', '')
xline(pars.bw(2), 'k--', 'DisplayName', '')
xlim([0 SAM.fs/2]*1e-6); % visualize only positive size
hold off;
xlabel('Frequency [MHz]');
ylabel('Norm Power Spectrum [dB]');
title('SAM Norm Power Spectrum');
legend('Location', 'Best');

exportgraphics(gcf,fullfile(figsDir,samName+"_powSp.png"), ...
   'Resolution','300')
end
%% DOF METHODS

band    = spectralData_sam.band;
depth   = spectralData_sam.depth;
[r,p,q] = size(SR);
f       = band(:); 

% In case mismatch of j_sam & j_ref, otherwise is 1
comp_freq_a = comp_mod_freq_a(alpha_ref,j_sam,j_ref,band,depth,q);

% Matrix (Gaussian)
% X = kron( speye(p*q), ones(size(f)) );
% Z = kron( speye(p*q), -f.^2 );
% W = kron( speye(p*q), -4*f.^j_sam );

% Matrix (Power Law)
X = kron( speye(p*q), ones(size(f)) );
Z = kron( speye(p*q), log(f) ); 
W = kron( speye(p*q), -4*f.^j_sam );

dy = 0.5*(diag(ones(p-1,1),1) - diag(ones(p-1,1),-1));
dy(1,1) = -1; dy(1,2) = 1; dy(end,end) = 1; dy(end,end-1) = -1;
Dy = sparse(kron(speye(q),dy));
z = 1E2*repmat(depth,1,q); % 1E2*spectralData_sam.depth * ones(1, q); % 2d array
dz = reshape(Dy*z(:),p,q);
dz(end,:) = dz(end-1,:);  

methods          = {'3-DoF', '2-DoF-a', '2-DoF-b', '2-DoF-n'};
maps_results_dof = cell(1,length(methods));
bsc_results_dof  = cell(1,length(methods));

% PRIORS
% if ~deltaPriorFix
% delta_b_prior       = log(db2pow(cell2mat(bsc_results_all{iSam, iRef}(3))));
% delta_n_prior       = cell2mat(bsc_results_all{iSam, iRef}(4));
% end


% Loop over methods
    for iMet = 1:length(methods)
        estim_method = methods{iMet};
        clear b n a

        if strcmp(estim_method, '3-DoF')

            SR_comp = SR .* comp_freq_a;
            Y = log(SR_comp);

            u_0 = initialize_rpl(Y, X, Z, W, mu_rpl_tv, par_rpl);
            [u_opt,~] = rpl_tv(Y, X, Z, W, mu_rpl_tv, u_0, par_rpl);

            b = u_opt(1:p*q);
            n = u_opt(p*q+1:2*p*q);
            a = u_opt(2*p*q+1:3*p*q);
            a_Np2dB = Np2dB*Dy*a./dz(:);

            % save 3dof results for priors later
            b_3dof = b; n_3dof = n; a_Np2dB_3dof = a_Np2dB;

        elseif strcmp(estim_method, '2-DoF-a')
            
            delta_alpha_prior = median(a_Np2dB_3dof(:)); % prior from 3DoF

            comp_ref    = comp_ref_a(-delta_alpha_prior,j_ref,band,depth,q);                
            SR_comp     = SR .* comp_ref .* comp_freq_a;
            Y = log(SR_comp);

            u_0 = initialize_rpl_a_prior(Y, X, Z, mu_rpl_tv, par_rpl);
            [u_opt,~] = rpl_tv_a_prior(Y, X, Z, mu_rpl_tv, u_0, par_rpl);
            
            b = u_opt(1:p*q);
            n = u_opt(p*q+1:2*p*q);
            a_Np2dB = delta_alpha_prior*ones(p*q, 1);

        elseif strcmp( estim_method, '2-DoF-b')
             
            % delta_b_prior = median(b_3dof(:)); % From 3DoF
            delta_b_prior = log(db2pow(delta_b_lu)); % From Lu et al 1999

            comp_ref    = comp_ref_b_bsc(delta_b_prior);
            SR_comp     = SR .* comp_ref .*comp_freq_a;
            Y = log(SR_comp);

            u_0 = initialize_rpl_b_prior(Y, Z, W, mu_rpl_tv, par_rpl);
            [u_opt,~] = rpl_tv_b_prior(Y, Z, W, mu_rpl_tv, u_0, par_rpl);
            
            n = u_opt(1:p*q);
            a = u_opt(p*q+1:2*p*q);
            b = delta_b_prior*ones(p*q, 1);
            a_Np2dB = Np2dB*Dy*a./dz(:);

        elseif strcmp( estim_method, '2-DoF-n')

            % delta_n_prior = median(n_3dof(:)); % From 3-DoF
            delta_n_prior = delta_n_lu; % From Lu et al 1999

            comp_ref    = comp_ref_n_bsc(delta_n_prior, band, p, q);
            SR_comp     = SR .* comp_ref .* comp_freq_a;
            Y = log(SR_comp);

            u_0 = initialize_rpl_n_prior(Y, X, W, mu_rpl_tv, par_rpl);
            [u_opt,~] = rpl_tv_n_prior(Y, X, W, mu_rpl_tv, u_0, par_rpl);

            b = u_opt(1:p*q);
            a = u_opt(p*q+1:2*p*q);
            n = delta_n_prior*ones(p*q, 1);
            a_Np2dB = Np2dB*Dy*a./dz(:);

        end

        % Compute final parameters
        b_ratio     = reshape(exp(b), p, q);
        b_ratio_dB  = 10*log10(b_ratio);
        alpha_ratio = reshape(a_Np2dB, p, q);
        n_ratio     = reshape(n, p, q); 
        acs_sam     = alpha_ratio + alpha_ref;

        % Compute statistics
        [m_a, s_a, cv_a] = deal(calc2dStats{1}(acs_sam), calc2dStats{2}(acs_sam), calc2dStats{3}(acs_sam));
        [m_b, s_b, cv_b] = deal(calc2dStats{1}(b_ratio_dB), calc2dStats{2}(b_ratio_dB), calc2dStats{3}(b_ratio_dB));
        [m_n, s_n, cv_n] = deal(calc2dStats{1}(n_ratio), calc2dStats{2}(n_ratio), calc2dStats{3}(n_ratio));

        % Save maps results
        % maps_results_dof{iMet} = {acs_sam, b_ratio_dB, n_ratio};

        maps_results_dof{iMet}.alpha = acs_sam;
        maps_results_dof{iMet}.b_dB  = b_ratio_dB;
        maps_results_dof{iMet}.n     = n_ratio;

        % Compute and save BSC results
        b_est = median(b_ratio(:));
        n_est = median(n_ratio(:));
        
        % Delta
        % bsc_est_gauss = b_est .* exp(-n_est .* band.^2);
        bsc_est_powlaw = b_est .* band.^n_est;

        % Reference fully known
        % OPTION A
        % b_sam     = b_ratio * b_ref;
        % n_sam     = n_ratio + n_ref;
        % bsc_sam   = b_sam *(freq_bsc.^n_sam);
        % med_bsc   = median(bsc_sam(:));
        % Delta_b*b_ref*f^(delta_n_prior +n_ref)

        bsc_results_dof{iMet}.bsc_powlaw = bsc_est_powlaw;

        fprintf('-----%s---\n', estim_method);
        fprintf('α_s        : %.4f ± %.4f, %%CV = %.4f\n', round(m_a, 3), round(s_a, 4), round(cv_a, 4));
            if plotBSCdB 
        fprintf('Δb [dB]    : %.4f ± %.4f, %%CV = %.4f\n', round(m_b, 3), round(s_b, 4), round(cv_b, 4));
            else
        fprintf('Δb         : %.4f ± %.4f, %%CV = %.4f\n', round(m_b, 3), round(s_b, 4), round(cv_b, 4));
            end    
        fprintf('Δn         : %.4f ± %.4f, %%CV = %.4f\n', round(m_n, 4), round(s_n, 4), round(cv_n, 4));
        fprintf('--------\n');

    end
methods      = {'3-DoF', '2-DoF-a', '2-DoF-b', '2-DoF-n'};
method_labels = { ...
    '\mathrm{3\textrm{-}DoF}', ...
    '\mathrm{2\textrm{-}DoF}_{\mathrm{b,n}}', ...
    '\mathrm{2\textrm{-}DoF}_{\mathrm{n,a}}', ...
    '\mathrm{2\textrm{-}DoF}_{\mathrm{b,a}}' ...
};
%% DISPLAY OVERLAY SIMPLE RECT
if plotRect

units           = 1E2;
bmodeFull       = bmode_sam;
% colorImg        = bigImg(acs_sam, spectralData_sam.rf_roi);
range_bmode     = [-60 0];
x_img           = spectralData_sam.lateral;
z_img           = spectralData_sam.depth*units;
xFull           = SAM.x;
zFull           = SAM.z*units;

[X,Z]   = meshgrid(xFull,zFull);
roi     = X >= x_img(1) & X <= x_img(end) & Z >= z_img(1) & Z <= z_img(end);

% %%%%%%%%%%%%%%%%%%%%%%% alpha %%%%%%%%%%%%%%%%%%%%%%%%
indices_alpha = [1, 3, 4];  % Corresponden a 3-DoF, 2-DoF-b, 2-DoF-n

figure('Units','pixels', 'Position',[50, 100, 1800, 500]) % [x, y, width, height]
tiledlayout(1,4, 'TileSpacing','compact', 'Padding','compact')

% Bmode
t1 = nexttile();
imagesc(xFull,zFull,bmodeFull,range_bmode); % axis image;
title(caption)
ylim(range_depth)
hold on
contour(xFull,zFull,roi,1,'w--')
hold off
xlabel('Lateral [°]')
ylabel('Depth [cm]')
hBm = colorbar('Ticks',-60:20:0);
% hBm = colorbar;
hBm.Label.String = 'dB';
hBm.Location = 'westoutside';
set(gca, 'fontsize', fontSize);

% alpha maps
for i = 1:length(indices_alpha)
    idx = indices_alpha(i);
    nexttile;
    [~,~,hColor] = imOverlayInterp(bmodeFull, maps_results_dof{idx}.alpha, range_bmode, range_acs, ...
                                   transparency, x_img, z_img, roi, xFull, zFull);
    axis normal;
    hold on;
    contour(xFull, zFull, roi, 2, 'w--')
    hold off;
    ylim(range_depth)
    xlabel('Lateral [°]'), 
    % ylabel('Depth [cm]');
   
    hColor.Label.String = 'dB\cdotcm^{-1}\cdotMHz^{-1}';
    title(sprintf('$%s: \\alpha_s = %.2f \\pm %.2f, \\%%CV = %.2f$', ...
        method_labels{idx}, ...
        mean(maps_results_dof{idx}.alpha(:), 'omitnan'), ...
        std(maps_results_dof{idx}.alpha(:), 'omitnan'), ...
        abs(cv2d(maps_results_dof{idx}.alpha))), ...
        'Interpreter', 'latex');
    set(gca, 'fontsize', fontSize);
end
colormap(t1,'gray')
exportgraphics(gcf,fullfile(figsDir,"sam_"+samName+"_a_rect.png"), ...
   'Resolution','300')

% %%%%%%%%%%%%%%%%%%%%%%%% b %%%%%%%%%%%%%%%%%%%%%%%%
indices_b = [1, 2, 4];  

figure('Units','pixels', 'Position',[50, 100, 1800, 500]) % [x, y, width, height]
tiledlayout(1,4, 'TileSpacing','compact', 'Padding','compact')

% Bmode
t1 = nexttile();
imagesc(xFull,zFull,bmodeFull,range_bmode); % axis image;
title(caption)
ylim(range_depth)
hold on
contour(xFull,zFull,roi,1,'w--')
hold off
xlabel('Lateral [°]')
ylabel('Depth [cm]')
hBm = colorbar('Ticks',-60:20:0);
% hBm = colorbar;
hBm.Label.String = 'dB';
hBm.Location = 'westoutside';
set(gca, 'fontsize', fontSize);

% Delta b maps
for i = 1:length(indices_b)
    idx = indices_b(i);
    nexttile;
    [~,~,hColor] = imOverlayInterp(bmodeFull, maps_results_dof{idx}.b_dB, range_bmode, range_delta_b, ...
                                   transparency, x_img, z_img, roi, xFull, zFull);
    axis normal;
    hold on;
    contour(xFull, zFull, roi, 2, 'w--')
    hold off;
    ylim(range_depth)
    xlabel('Lateral [°]'),
    % ylabel('Depth [cm]');
    hColor.Label.String = 'dB';
    title(sprintf('$%s: \\Delta b = %.2f \\pm %.2f, \\%%CV = %.2f$', ...
        method_labels{idx}, ...
        mean(maps_results_dof{idx}.b_dB(:), 'omitnan'), ...
        std(maps_results_dof{idx}.b_dB(:), 'omitnan'), ...
        abs(cv2d(maps_results_dof{idx}.b_dB))), ...
        'Interpreter', 'latex');
    set(gca, 'fontsize', fontSize);
end
colormap(t1,'gray')
exportgraphics(gcf,fullfile(figsDir,"sam_"+samName+"_b_rect.png"), ...
   'Resolution','300')

% %%%%%%%%%%%%%%%%%%%%%% n %%%%%%%%%%%%%%%%%%%%%%%%
indices_n = [1, 2, 3];  

figure('Units','pixels', 'Position',[50, 100, 1800, 500]) % [x, y, width, height]
tiledlayout(1,4, 'TileSpacing','compact', 'Padding','compact')

% Bmode
t1 = nexttile();
imagesc(xFull,zFull,bmodeFull,range_bmode); % axis image;
title(caption)
ylim(range_depth)
hold on
contour(xFull,zFull,roi,1,'w--')
hold off
xlabel('Lateral [°]')
ylabel('Depth [cm]')
hBm = colorbar('Ticks',-60:20:0);
% hBm = colorbar;
hBm.Label.String = 'dB';
hBm.Location = 'westoutside';
set(gca, 'fontsize', fontSize);

%Delta n
for i = 1:length(indices_n)
    idx = indices_n(i);
    nexttile;
    [~,~,hColor] = imOverlayInterp(bmodeFull, maps_results_dof{idx}.n, range_bmode, range_delta_n, ...
                                   transparency, x_img, z_img, roi, xFull, zFull);
    axis normal;
    hold on;
    contour(xFull, zFull, roi, 2, 'w--')
    hold off;
    ylim(range_depth)
    xlabel('Lateral [°]'),
    % ylabel('Depth [cm]');  
    hColor.Label.String = 'a.u.';
    title(sprintf('$%s: \\Delta n = %.2f \\pm %.2f, \\%%CV = %.2f$', ...
        method_labels{idx}, ...
        mean(maps_results_dof{idx}.n(:), 'omitnan'), ...
        std(maps_results_dof{idx}.n(:), 'omitnan'), ...
        abs(cv2d(maps_results_dof{idx}.n))), ...
        'Interpreter', 'latex');
    set(gca, 'fontsize', fontSize);
end
colormap(t1,'gray')
exportgraphics(gcf,fullfile(figsDir,"sam_"+samName+"_n_rect.png"), ...
    'Resolution','300')
end

%%  DISPLAY OVERLAY SIMPLE POLAR
if plotPolar

xPolar  = SAM.xp;
zPolar  = SAM.zp + 0.0101; % Trans.radiusMm*1e-3*(1-cos(phi(1)))
% zPolar  = SAM.zp;
z0Polar = SAM.z0p; 
r0      = SAM.r0;

parProbe = getparam('C5-2v');
[~,~,z0Polar2] = impolgrid(size(bmode_sam), SAM.z(end)+r0, parProbe);

% Plot in cartesian cords
[TH_acs,R_acs]          = meshgrid(-x_img*pi/180 + pi/2,z_img/100+r0);
[xPolarACS,zPolarACS]   = pol2cart(TH_acs,R_acs);
zPolarACS               = zPolarACS + z0Polar;

%%%%%%%%%%%%%%%%%%%%%%% BMODE %%%%%%%%%%%%%%%%%%%%%%%
figure('Units', 'pixels', 'Position', [50, 100, 400, 300]); % [x, y, width, height]
[ax1,~] = imOverlayPolar(bmodeFull,ones(size(maps_results_dof{1}.alpha)),range_bmode,range_acs,0, ...
    xPolar,zPolar,xPolarACS,zPolarACS);
% yticks(ax1,[4 8 12 16])
xlabel(ax1,'Lateral [cm]'), ylabel(ax1,'Axial [cm]')
title(ax1, samName, 'Interpreter', 'none');
xlim([-9 9])
ylim(range_depth)
hold on
contour(xPolar*1e2, zPolar*1e2, roi,1,'w--')
hold off
set(gca, 'fontsize', fontSize);
% exportgraphics(gcf,fullfile(figsPolDir,"sam_"+samName+"_pol"+num2str(idx)+".png"), ...
% 'Resolution','300')

%% QUS PARAMETERS

%%%%%%%%%%%%%%%%%%%%%%%% alpha %%%%%%%%%%%%%%%%%%%%%%%%
indices_alpha = [1, 3, 4];  % Corresponden a 3-DoF, 2-Dof-a, 2-DoF-b, 2-DoF-n

for i = 1:length(indices_alpha)
    figure('Units', 'pixels', 'Position', [50, 100, 400, 300]); % [x, y, width, height]
    idx = indices_alpha(i);

    % [ax1,~] = imOverlayPolar(bmodeFull,ones(size(maps_results_dof{1}.alpha)),range_bmode,range_acs,0, ...
    %     xPolar,zPolar,xPolarACS,zPolarACS);
    [ax1,~] = imOverlayPolar(bmodeFull,maps_results_dof{idx}.alpha,range_bmode,range_acs,transparency, ...
        xPolar,zPolar,xPolarACS,zPolarACS);
    % yticks(ax1,[4 8 12 16])
    xlabel(ax1,'Lateral [cm]'), ylabel(ax1,'Axial [cm]')

    title(ax1, sprintf('$%s: \\alpha_s = %.2f \\pm %.2f, \\%%CV = %.2f$', ...
        method_labels{idx}, ...
        mean(maps_results_dof{idx}.alpha(:), 'omitnan'), ...
        std(maps_results_dof{idx}.alpha(:), 'omitnan'), ...
        abs(cv2d(maps_results_dof{idx}.alpha))), ...
        'Interpreter', 'latex');

    xlim([-9 9])
    ylim(range_depth)
    hold on
    contour(xPolar*1e2, zPolar*1e2, roi,1,'w--')
    hold off
    % colorbar 
    % hColor.Label.String = 'dB\cdotcm^{-1}\cdotMHz^{-1}';
    set(gca, 'fontsize', fontSize);
    exportgraphics(gcf,fullfile(figsPolDir,"sam_"+samName+"_a_pol"+num2str(idx)+".png"), ...
    'Resolution','300')
end

%% %%%%%%%%%%%%%%%%%%%%%% b %%%%%%%%%%%%%%%%%%%%%%%%
indices_b = [1, 2, 4];  % Corresponden a 3-DoF, 2-Dof-a, 2-DoF-b, 2-DoF-n

for i = 1:length(indices_b)
    figure('Units', 'pixels', 'Position', [50, 100, 400, 300]); % [x, y, width, height]
    idx = indices_b(i);

    % [ax1,~] = imOverlayPolar(bmodeFull,ones(size(maps_results_dof{1}.alpha)),range_bmode,range_acs,0, ...
    %     xPolar,zPolar,xPolarACS,zPolarACS);
    [ax1,~] = imOverlayPolar(bmodeFull,maps_results_dof{idx}.b_dB,range_bmode,[ ],transparency, ...
        xPolar,zPolar,xPolarACS,zPolarACS);
    % yticks(ax1,[4 8 12 16])
    xlabel(ax1,'Lateral [cm]'), ylabel(ax1,'Axial [cm]') 
    title(ax1, sprintf('$%s: \\Delta b = %.2f \\pm %.2f, \\%%CV = %.2f$', ...
        method_labels{idx}, ...
        mean(maps_results_dof{idx}.b_dB(:), 'omitnan'), ...
        std(maps_results_dof{idx}.b_dB(:), 'omitnan'), ...
        abs(cv2d(maps_results_dof{idx}.b_dB))), ...
        'Interpreter', 'latex');
    xlim([-9 9])
    ylim(range_depth)
    hold on
    contour(xPolar*1e2, zPolar*1e2, roi,1,'w--')
    hold off
    % colorbar 
    % hColor.Label.String = 'dB\cdotcm^{-1}\cdotMHz^{-1}';
    set(gca, 'fontsize', fontSize);
     exportgraphics(gcf,fullfile(figsPolDir,"sam_"+samName+"_b_pol"+num2str(idx)+".png"), ...
    'Resolution','300')
end

%% %%%%%%%%%%%%%%%%%%%%%% n %%%%%%%%%%%%%%%%%%%%%%%%
indices_b = [1, 2, 3];  % Corresponden a 3-DoF, 2-Dof-a, 2-DoF-b, 2-DoF-n

for i = 1:length(indices_b)
    figure('Units', 'pixels', 'Position', [50, 100, 400, 300]); % [x, y, width, height]
    idx = indices_b(i);
    % [ax1,~] = imOverlayPolar(bmodeFull,ones(size(maps_results_dof{1}.alpha)),range_bmode,range_acs,0, ...
    %     xPolar,zPolar,xPolarACS,zPolarACS);
    [ax1,~] = imOverlayPolar(bmodeFull,maps_results_dof{idx}.n,range_bmode,[ ],transparency, ...
        xPolar,zPolar,xPolarACS,zPolarACS);
    % yticks(ax1,[4 8 12 16])
    xlabel(ax1,'Lateral [cm]'), ylabel(ax1,'Axial [cm]')
    title(ax1, sprintf('$%s: \\Delta n = %.2f \\pm %.2f, \\%%CV = %.2f$', ...
        method_labels{idx}, ...
        mean(maps_results_dof{idx}.n(:), 'omitnan'), ...
        std(maps_results_dof{idx}.n(:), 'omitnan'), ...
        abs(cv2d(maps_results_dof{idx}.n))), ...
        'Interpreter', 'latex');
    xlim([-9 9])
    ylim(range_depth)
    hold on
    contour(xPolar*1e2, zPolar*1e2, roi,1,'w--')
    hold off
    % colorbar 
    % hColor.Label.String = 'dB\cdotcm^{-1}\cdotMHz^{-1}';
    set(gca, 'fontsize', fontSize);
    exportgraphics(gcf,fullfile(figsPolDir,"sam_"+samName+"_n_pol"+num2str(idx)+".png"), ...
    'Resolution','300')
end

end

end
%% SAVING DATA
if roi_already
    % Saving ACS maps and ROI
    save(fullfile(resultsDir,samName+".mat"), ...
        'maps_results_dof','bsc_results_dof','rect')
else
    % first time working with roi
    save(fullfile(roisDir,samName+".mat"), ...
    'rect')

end

close all
pause (0.5);
end
%% Auxiliary functions
% Get delays
function [t_delay] = getRXDelays(Trans, t, n_elements, n_pulses, sound_speed, wvl)

t_delay = zeros(length(t), n_elements, n_pulses);
% (x, z) [m] Obtain positions of center of every element
element_pos_x = Trans.ElementPos(:, 1)*wvl;
element_pos_z = Trans.ElementPos(:, 3)*wvl;
phi = Trans.ElementPos(:, 4);

for n = 1:n_pulses
    for e = 1:n_elements
        focus = sound_speed*t(:)/2;
        xfocus = element_pos_x(n) + sin(phi(n)) * focus;
        zfocus = element_pos_z(n) + cos(phi(n)) * focus;
        t_delay(:,e,n) = (focus + sqrt((zfocus- element_pos_z(e)).^2 + ...
            (xfocus - element_pos_x(e)).^2))/sound_speed;
    end
end

end